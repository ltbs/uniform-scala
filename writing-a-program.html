<html><head><title>uniform-scala: Writing a program</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Luke Tebbs" /><meta name="description" content="Purely functional user-interaction" /><meta name="og:image" content="/uniform-scala/img/poster.png" /><meta name="og:title" content="uniform-scala: Writing a program" /><meta name="og:site_name" content="uniform-scala" /><meta name="og:url" content="https://ltbs.github.io/uniform-scala/" /><meta name="og:type" content="website" /><meta name="og:description" content="Purely functional user-interaction" /><link rel="icon" type="image/png" href="/uniform-scala/img/favicon.png" /><meta name="twitter:title" content="uniform-scala: Writing a program" /><meta name="twitter:image" content="https://ltbs.github.io/uniform-scala/img/poster.png" /><meta name="twitter:description" content="Purely functional user-interaction" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/uniform-scala/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/uniform-scala/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/uniform-scala/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/uniform-scala/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/uniform-scala/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/uniform-scala/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/uniform-scala/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/uniform-scala/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/uniform-scala/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/uniform-scala/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/uniform-scala/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/uniform-scala/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/uniform-scala/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/uniform-scala/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/uniform-scala/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/uniform-scala/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/uniform-scala/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/uniform-scala/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/uniform-scala/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/uniform-scala/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/uniform-scala/highlight/styles/color-brewer.css" /><link rel="stylesheet" href="/uniform-scala/css/style.css" /><link rel="stylesheet" href="/uniform-scala/css/palette.css" /><link rel="stylesheet" href="/uniform-scala/css/codemirror.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/uniform-scala/" class="brand"><div class="brand-wrapper"><span>uniform-scala</span></div></a></li> <li><a href="/uniform-scala/index.html" class="">Home</a></li> <li><a href="/uniform-scala/setup.html" class="">Setup</a></li> <li><a href="/uniform-scala/writing-a-program.html" class=" active ">Writing a program</a></li> <li><a href="/uniform-scala/interpreters.html" class="">Interpreters</a> <ul class="sub_section"> <li><a href="/uniform-scala/interpreter-cli.html" class="">CLI Interpreter</a></li> <li><a href="/uniform-scala/interpreter-logic-table.html" class="">Logic Table Interpreter</a></li> <li><a href="/uniform-scala/interpreter-play.html" class="">Play Framework Interpreter</a></li> <li><a href="/uniform-scala/interpreter-static-site.html" class="">Static Site interpreter</a></li> <li><a href="/uniform-scala/interpreter-selenium.html" class="">Selenium Interpreter</a></li></ul></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/ltbs/uniform-scala"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/ltbs/uniform-scala"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li><li><a href="#" onclick="shareSiteTwitter('uniform-scala Purely functional user-interaction');"><i class="fa fa-twitter"></i></a></li><li><a href="#" onclick="shareSiteFacebook('uniform-scala Purely functional user-interaction');"><i class="fa fa-facebook"></i></a></li><li><a href="#" onclick="shareSiteGoogle();"><i class="fa fa-google-plus"></i></a></li></ul></div></div></div></div><div id="content" data-github-owner="ltbs" data-github-repo="uniform-scala"><div class="content-wrapper"><section><h1 id="imports">Imports</h1>

<p>Uniform is built upon <em>monad stacks</em>, and uses the <a href="https://github.com/atnos-org/eff">Eff Monad
Library</a> to do the heavy
lifting. When writing a program you need to import this library -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">org.atnos.eff._</span>
</code></pre></div></div>

<p>You will also need to import the core uniform library. You do not need
to import any interpreters when merely defining the program.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">ltbs.uniform._</span>
</code></pre></div></div>

<h1 id="writing-a-program">Writing a program</h1>

<p>The program itself defines the user-journey or interaction you wish to
model. It is completely abstract at this point and the interpreter
gets to decide how to represent the questions.</p>

<h2 id="ask-function-uask">Ask function (<code class="highlighter-rouge">uask</code>)</h2>

<p>The most basic interaction with the user is the <code class="highlighter-rouge">uask</code> function - it
needs a name and a data type -</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>uask[Stack,Int]("favouriteNumber")
</code></pre></div></div>

<p>However this code alone will fail -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">uask</span><span class="o">[</span><span class="kt">Stack</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"favouriteNumber"</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">19</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="k">type</span> <span class="kt">Stack</span>
       <span class="n">uask</span><span class="o">[</span><span class="kt">Stack</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"favouriteNumber"</span><span class="o">)</span>
            <span class="o">^</span>
</code></pre></div></div>

<p>In order to run our program must be
applied to a monad stack. And this
stack must know about every data-type you will ask the users.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">intOnlyProgram</span><span class="o">[</span><span class="kt">Stack</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="n">uask</span><span class="o">[</span><span class="kt">Stack</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"favouriteNumber"</span><span class="o">)</span>
</code></pre></div></div>

<p>This represents prompting the user for a value - in this case an
<code class="highlighter-rouge">Int</code>.</p>

<p>Optional fields are treated as you would expect, as are lists -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">intListProgram</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="s">"favouriteNumbers"</span><span class="o">)</span>

<span class="k">def</span> <span class="n">stringOptProgram</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"optionalDescription"</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="composition">Composition</h2>

<p>Each statement in the program (such as <code class="highlighter-rouge">uask</code>) is monadic - you can
compose the questions inside a for comprehension, assign them to
variables and even build big programs from smaller programs.</p>

<p>Suppose we have a case class called <code class="highlighter-rouge">Pizza</code></p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Pizza</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">toppings</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">base</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>We could then write a program to collect the values, it has a return
type of <code class="highlighter-rouge">Eff[S, Pizza]</code>. We must however be careful to include <em>all</em>
the values you want to include in the stack -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">pizzaProgram</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">?</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Eff</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Pizza</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
     <span class="o">|</span>   <span class="n">size</span>     <span class="k">&lt;-</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"size"</span><span class="o">)</span>
     <span class="o">|</span>   <span class="n">toppings</span> <span class="k">&lt;-</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"toppings"</span><span class="o">)</span>
     <span class="o">|</span>   <span class="n">base</span>     <span class="k">&lt;-</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"base"</span><span class="o">)</span>
     <span class="o">|</span> <span class="o">}</span> <span class="k">yield</span> <span class="nc">Pizza</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">toppings</span><span class="o">,</span> <span class="n">base</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">22</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">instance</span> <span class="kt">found</span> <span class="kt">for</span> <span class="kt">MemberIn</span><span class="o">[[</span><span class="kt">β$2$</span><span class="o">]</span><span class="kt">ltbs.uniform.UniformAsk</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">β$2$</span><span class="o">]</span>, <span class="kt">S</span><span class="o">].</span>
<span class="nc">The</span> <span class="n">effect</span> <span class="o">[</span><span class="kt">β$2$</span><span class="o">]</span><span class="n">ltbs</span><span class="o">.</span><span class="n">uniform</span><span class="o">.</span><span class="nc">UniformAsk</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">β$2$</span><span class="o">]</span> <span class="n">is</span> <span class="n">not</span> <span class="n">part</span> <span class="n">of</span> <span class="n">the</span> <span class="n">stack</span> <span class="n">S</span>
         <span class="n">toppings</span> <span class="k">&lt;-</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"toppings"</span><span class="o">)</span>
                                         <span class="o">^</span>
</code></pre></div></div>

<p>This error message is telling us that we are trying to create a
program that needs to be able to ask the user for <code class="highlighter-rouge">Int</code>’s and
<code class="highlighter-rouge">List[String]</code>’s, but we want it to be executable by interpreters that
don’t need to know how to ask the user for a <code class="highlighter-rouge">List[String]</code>. Obviously
this cannot work, so we must add <code class="highlighter-rouge">_uniform[List[String], ?]</code> to our
stack -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pizzaProgram</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Eff</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Pizza</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">size</span>     <span class="k">&lt;-</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"size"</span><span class="o">)</span>
  <span class="n">toppings</span> <span class="k">&lt;-</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"toppings"</span><span class="o">)</span>
  <span class="n">base</span>     <span class="k">&lt;-</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"base"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nc">Pizza</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">toppings</span><span class="o">,</span> <span class="n">base</span><span class="o">)</span>
</code></pre></div></div>

<p>Alternatively we can use the <a href="https://typelevel.org/cats/">Cats</a>
library and take advantage of the applicative syntax for something a
bit terser -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="n">pizzaProgram2</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Eff</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Pizza</span><span class="o">]</span> <span class="k">=</span> 
<span class="o">(</span>
  <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"size"</span><span class="o">),</span> 
  <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="s">"toppings"</span><span class="o">),</span>
  <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"base"</span><span class="o">)</span>
<span class="o">).</span><span class="n">mapN</span><span class="o">(</span><span class="nc">Pizza</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="selection-functions-uaskoneof-and-uasknof">Selection functions (<code class="highlighter-rouge">uaskOneOf</code> and <code class="highlighter-rouge">uaskNOf</code>)</h2>

<p>Sometimes we only want to offer the user a subset of the possible
values contained within a datatype to choose from. For this we have
two dedicated functions -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">pizzaProgram3</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniformSelect</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniformSelect</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">?</span><span class="o">]</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">?</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Eff</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Pizza</span><span class="o">]</span> <span class="k">=</span> 
<span class="o">(</span>
  <span class="n">uaskOneOf</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"size"</span><span class="o">,</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)),</span> 
  <span class="n">uaskNOf</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">String</span><span class="o">](</span><span class="s">"toppings"</span><span class="o">,</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"olives"</span><span class="o">,</span> <span class="s">"capers"</span><span class="o">,</span> <span class="s">"pineapple"</span><span class="o">)).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">),</span>
  <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"base"</span><span class="o">)</span>
<span class="o">).</span><span class="n">mapN</span><span class="o">(</span><span class="nc">Pizza</span><span class="o">)</span>
</code></pre></div></div>

<p>Notice that we have a separate <code class="highlighter-rouge">_uniform[Int,?]</code> and
<code class="highlighter-rouge">_uniformSelect[Int,?]</code> in the type signature - they are not the same 
thing because the interpreter will probably want to ask the user for
these values in a different way.</p>

<h2 id="branching-logic">Branching Logic</h2>

<p>If you want to conditionally ask a question there are a number of ways
to do it. The most flexible is to use the normal scala <code class="highlighter-rouge">if</code> or <code class="highlighter-rouge">case</code>
statements
-</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">conditionalProgram</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniformSelect</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">?</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Eff</span><span class="o">[</span><span class="kt">S</span>, <span class="o">(</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">)]</span> <span class="k">=</span>
<span class="k">for</span> <span class="o">{</span>
  <span class="n">size</span>     <span class="k">&lt;-</span> <span class="n">uaskOneOf</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"size"</span><span class="o">,</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
  <span class="n">discount</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">String</span><span class="o">](</span><span class="s">"discountCode"</span><span class="o">)</span>
              <span class="k">else</span>           <span class="nc">Eff</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">String</span><span class="o">](</span><span class="s">""</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">discount</span><span class="o">)</span>
</code></pre></div></div>

<p>In this example the user will only be prompted for a discount code if
they have asked for a large pizza, if they do not provide one the
discount code will be set to the empty string (<code class="highlighter-rouge">""</code>).</p>

<h2 id="optional-fields-when">Optional fields (<code class="highlighter-rouge">when</code>)</h2>

<p>There are two functions you can use to simplify this. The first is
<code class="highlighter-rouge">when</code> and is used as follows -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">conditionalProgram2</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniformSelect</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">?</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Eff</span><span class="o">[</span><span class="kt">S</span>, <span class="o">(</span><span class="kt">Int</span>,<span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])]</span> <span class="k">=</span>
     <span class="o">|</span> <span class="k">for</span> <span class="o">{</span>
     <span class="o">|</span>   <span class="n">size</span>     <span class="k">&lt;-</span> <span class="n">uaskOneOf</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Int</span><span class="o">](</span><span class="s">"size"</span><span class="o">,</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
     <span class="o">|</span>   <span class="n">discount</span> <span class="k">&lt;-</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">String</span><span class="o">](</span><span class="s">"discountCode"</span><span class="o">)</span> <span class="n">when</span> <span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
     <span class="o">|</span> <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">discount</span><span class="o">)</span>
<span class="n">conditionalProgram2</span><span class="k">:</span> <span class="err">[</span><span class="kt">S</span><span class="err">]</span><span class="o">(</span><span class="kt">implicit</span> <span class="kt">evidence$1:</span> <span class="kt">org.atnos.eff.MemberIn</span><span class="o">[[</span><span class="kt">β$1$</span><span class="o">]</span><span class="kt">ltbs.uniform.UniformSelect</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">β$1$</span><span class="o">]</span>,<span class="kt">S</span><span class="o">],</span> <span class="k">implicit</span> <span class="n">evidence$2</span><span class="k">:</span> <span class="kt">org.atnos.eff.MemberIn</span><span class="o">[[</span><span class="kt">β$0$</span><span class="o">]</span><span class="kt">ltbs.uniform.UniformAsk</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">β$0$</span><span class="o">]</span>,<span class="kt">S</span><span class="o">])</span><span class="n">org</span><span class="o">.</span><span class="n">atnos</span><span class="o">.</span><span class="n">eff</span><span class="o">.</span><span class="nc">Eff</span><span class="o">[</span><span class="kt">S</span>,<span class="o">(</span><span class="kt">Int</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])]</span>
</code></pre></div></div>

<p>This is similar to the previous example, except that it returns an
<code class="highlighter-rouge">Option[String]</code> rather than a string. The argument to <code class="highlighter-rouge">when</code> can be
either a normal predicate, or another uniform journey provided that that
journey returns a <code class="highlighter-rouge">Boolean</code>. For example if we wanted to first ask the
user if they have a discount code and then only if they say yes to
prompt them for the code itself -</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">discountProgram</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">?</span><span class="o">]</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">?</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Eff</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
     <span class="o">|</span>   <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">String</span><span class="o">](</span><span class="s">"discountCode"</span><span class="o">)</span> <span class="n">when</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Boolean</span><span class="o">](</span><span class="s">"haveDiscountCode"</span><span class="o">)</span>
<span class="n">discountProgram</span><span class="k">:</span> <span class="err">[</span><span class="kt">S</span><span class="err">]</span><span class="o">(</span><span class="kt">implicit</span> <span class="kt">evidence$1:</span> <span class="kt">org.atnos.eff.MemberIn</span><span class="o">[[</span><span class="kt">β$0$</span><span class="o">]</span><span class="kt">ltbs.uniform.UniformAsk</span><span class="o">[</span><span class="kt">Boolean</span>,<span class="kt">β$0$</span><span class="o">]</span>,<span class="kt">S</span><span class="o">],</span> <span class="k">implicit</span> <span class="n">evidence$2</span><span class="k">:</span> <span class="kt">org.atnos.eff.MemberIn</span><span class="o">[[</span><span class="kt">β$0$</span><span class="o">]</span><span class="kt">ltbs.uniform.UniformAsk</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">β$0$</span><span class="o">]</span>,<span class="kt">S</span><span class="o">])</span><span class="n">org</span><span class="o">.</span><span class="n">atnos</span><span class="o">.</span><span class="n">eff</span><span class="o">.</span><span class="nc">Eff</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
</code></pre></div></div>

<h2 id="monoid-fields-emptyunless">Monoid fields (<code class="highlighter-rouge">emptyUnless</code>)</h2>

<p>If we wanted to keep the previous behaviour of returning an empty
string in the event of the user ordering a small pizza there is
likewise a number of ways we can achieve this. A clumbsy option would be to use
the <code class="highlighter-rouge">map</code> function -</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def discountProgram2[S : _uniform[Boolean, ?] : _uniform[String, ?]]: Eff[S, String] =
  (uask[S,String]("discountCode") when uask[S,Boolean]("haveDiscountCode"))
    .map(_.getOrElse(""))
</code></pre></div></div>

<p>This works because unform journeys are monadic and all monads are also
functors. Because functors provide <code class="highlighter-rouge">map</code> as long as you have a
journey of type <code class="highlighter-rouge">Uniform[A]</code> and a function of type <code class="highlighter-rouge">A ⇒ B</code> you can
therefore produce a <code class="highlighter-rouge">Uniform[B]</code>.</p>

<p>However there is a convenience method for this too. If you have a
<code class="highlighter-rouge">Uniform[A]</code> and you know that <code class="highlighter-rouge">A</code> is a Monoid you can use the
<code class="highlighter-rouge">emptyUnless</code> function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">discountProgram3</span><span class="o">[</span><span class="kt">S</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">Boolean</span>, <span class="kt">?</span><span class="o">]</span> <span class="kt">:</span> <span class="k">_</span><span class="kt">uniform</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">?</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Eff</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
     <span class="o">|</span>   <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">String</span><span class="o">](</span><span class="s">"discountCode"</span><span class="o">)</span> <span class="n">emptyUnless</span> <span class="n">uask</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">Boolean</span><span class="o">](</span><span class="s">"haveDiscountCode"</span><span class="o">)</span>
<span class="n">discountProgram3</span><span class="k">:</span> <span class="err">[</span><span class="kt">S</span><span class="err">]</span><span class="o">(</span><span class="kt">implicit</span> <span class="kt">evidence$1:</span> <span class="kt">org.atnos.eff.MemberIn</span><span class="o">[[</span><span class="kt">β$0$</span><span class="o">]</span><span class="kt">ltbs.uniform.UniformAsk</span><span class="o">[</span><span class="kt">Boolean</span>,<span class="kt">β$0$</span><span class="o">]</span>,<span class="kt">S</span><span class="o">],</span> <span class="k">implicit</span> <span class="n">evidence$2</span><span class="k">:</span> <span class="kt">org.atnos.eff.MemberIn</span><span class="o">[[</span><span class="kt">β$0$</span><span class="o">]</span><span class="kt">ltbs.uniform.UniformAsk</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">β$0$</span><span class="o">]</span>,<span class="kt">S</span><span class="o">])</span><span class="n">org</span><span class="o">.</span><span class="n">atnos</span><span class="o">.</span><span class="n">eff</span><span class="o">.</span><span class="nc">Eff</span><span class="o">[</span><span class="kt">S</span>,<span class="kt">String</span><span class="o">]</span>
</code></pre></div></div>

<p>Otherwise <code class="highlighter-rouge">emptyUnless</code> works identically to <code class="highlighter-rouge">when</code> except that it
returns an <code class="highlighter-rouge">A</code> rather than an <code class="highlighter-rouge">Option[A]</code>.</p>

</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/uniform-scala/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'ltbs/uniform-scala'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/uniform-scala/js/main.js"></script></body></html>