// When the user clicks on the search box, we want to toggle the search dropdown
function displayToggleSearch(e) {
  e.preventDefault();
  e.stopPropagation();

  closeDropdownSearch(e);
  
  if (idx === null) {
    console.log("Building search index...");
    prepareIdxAndDocMap();
    console.log("Search index built.");
  }
  const dropdown = document.querySelector("#search-dropdown-content");
  if (dropdown) {
    if (!dropdown.classList.contains("show")) {
      dropdown.classList.add("show");
    }
    document.addEventListener("click", closeDropdownSearch);
    document.addEventListener("keydown", searchOnKeyDown);
    document.addEventListener("keyup", searchOnKeyUp);
  }
}

//We want to prepare the index only after clicking the search bar
var idx = null
const docMap = new Map()

function prepareIdxAndDocMap() {
  const docs = [  
    {
      "title": "Advanced",
      "url": "/uniform-scala/core/advanced.html",
      "content": "Advanced Techniques This section discusses the internals of how Uniform works, and how to write custom interpreters."
    } ,    
    {
      "title": "Alternative templating technologies",
      "url": "/uniform-scala/interpreter-play27/alternative-templating.html",
      "content": "The play interpreter rendering can be easily swapped out and works as well with Scalatags as it does with twirl. scalatags Scalatags is an attractive alternative when doing web development in scala, and it is easy to swap out the rendering to use this instead of twirl. Firstly you will need to have scalatags as a library dependency. Secondly you will need to tell the Play Framework how to render the Tag type - package controllers import play.api.http.{Writeable, ContentTypeOf, ContentTypes} import play.api.mvc.Codec import scalatags.Text.all._ trait ScalatagsSupport { implicit def contentTypeOfTag(implicit codec: Codec): ContentTypeOf[Tag] = { ContentTypeOf[Tag](Some(ContentTypes.HTML)) } implicit def writeableOfTag(implicit codec: Codec): Writeable[Tag] = { Writeable(tag =&gt; codec.encode(\"&lt;!DOCTYPE html&gt;\\n\" + tag.render)) } } object ScalatagsSupport extends ScalatagsSupport Now all you need to do is to implement your controller to extend PlayInterpreter[Tag] and ScalatagsSupport rather than PlayInterpreter[Html]. other technologies As you can see PlayInterpreter can support any datatype for rendering and as such it should be possible to plug in whichever technology you prefer for rendering. While it is possible to have two controllers use different rendering technologies within the same project this is not advised as it limits reuse of components - you will likely find yourself having to write a WebAsk[Tag, Int] as well as a WebAsk[Html, Int]."
    } ,    
    {
      "title": "Asking",
      "url": "/uniform-scala/core/asks.html",
      "content": "An ask is a step in a Uniform journey that requests information from the user. Asking Whereas a tell represents sending typed information to the user an ask is the reverse - it represents prompting the user to supply some data. For example to ask the user to enter an Int value with a step id of “age” we would type - import ltbs.uniform._ ask[Int](\"age\") default values We can supply a default value for an ask, and this can depend upon other values in scope - val defaultAge = 39 ask[Int](\"age\", default = Some(defaultAge)) validation rules Values can be validated by specifying one or more typed Rules, these can be used to restrict any value that the user inputs via an ask, and can be composed of other rules to provide more complex behaviour. At it’s simplest a Rule is a test (predicate) against the value supplied by a user and an error message key that is emitted if test fails. existing validation rules There are a number of predefined Rules you can pick from - import ltbs.uniform.validation._ ask[String](\"name\", validation = Rule.nonEmpty) ask[Int](\"age\", validation = Rule.between(18, 120)) bespoke validation rules Alternatively you can create completely custom Rules - val postcodeRegex = \"^[A-Z]{1,2}\\\\d[A-Z\\\\d]? ?\\\\d[A-Z]{2}$\" val postcodeCheck = Rule.cond[String]( _.matches(postcodeRegex), \"bad-postcode\" ) ask[String](\"postcode\", validation = postcodeCheck) validation rules on the REPL You can also test the validation rules in isolation, if you wish - postcodeCheck.apply(\"AB12 3CD\") // res5: cats.data.Validated[ErrorTree, String] = Valid(\"AB12 3CD\") postcodeCheck.apply(\"BAD POSTCODE\") // res6: cats.data.Validated[ErrorTree, String] = Invalid( // ListMap( // NonEmptyList(List(), List()) -&gt; NonEmptyList(ErrorMsg(\"bad-postcode\", WrappedArray()), List()) // ) // ) Rule.lengthBetween[String](1,30).apply(\"acceptable\") // res7: cats.data.Validated[ErrorTree, String] = Valid(\"acceptable\") combining validation rules Sometimes you may wish to use several validation rules together for a single value, for example if we wish to check that a day is in the past and that it is a weekday we might use two rules as follows - import java.time.LocalDate val weekdayRule = Rule.cond[LocalDate]( _.getDayOfWeek.getValue &lt; 6, \"not-a-weekday\" ) // add an order instance to allow LocalDate to be used with max implicit val orderDate = cats.Order.from[LocalDate]{ case (a,b) =&gt; a.toEpochDay compare b.toEpochDay } val inPastRule = Rule.max(LocalDate.now.minusDays(1)) We could combine these rules sequentially by using followedBy - ask[String]( \"postcode\", validation=Rule.nonEmpty[String] followedBy postcodeCheck ) In this situation the second rule will only be evaluated if the first rule passes (fail fast semantics). You may wish to do this if it only makes sense to display a single error message. In the above example if the user inputs an empty string we would only want them to see a single error message, not both. However you may wish for the two be applied together regardless (error accumulating semantics), for this you would use alongWith - ask[LocalDate]( \"start-date\", validation=weekdayRule alongWith inPastRule ) In this case we want the user to be notified as such if the address they enter is both not a weekday and also not in the past, this saves the user from having to correct one problem and resubmit only to be told there is another error. validation rules for compound types You may wish to write a validation rule for a complex datatype, for example lets suppose that we want to create an address type containing a postcode - case class Address( line1: String, line2: String, line3: String, postcode: String ) val badAddress: Address = Address( \"1 The Commons\", \"Genericford\", \"Madeupshire\", \"BAD POSTCODE\" ) val goodAddress: Address = Address( \"The Scottish Parliament\", \"\", \"Edinburgh\", \"EH99 1SP\" ) We can now create a test that inspects the postcode within the address - val addressCheck = Rule.cond[Address]( _.postcode.matches(postcodeRegex), \"bad-postcode\" ) Errors are formed into an ErrorTree, which means they have a position in a hierarchy that mirrors the datatype being tested. When calling apply on a Rule we will get back a cats.data.Validated, the right side will contain the object returned unchanged if the validation passes, and the left side will contain an ErrorTree if the validation fails. import cats.data.Validated val Validated.Valid(result) = addressCheck(goodAddress) // result: Address = Address( // \"The Scottish Parliament\", // \"\", // \"Edinburgh\", // \"EH99 1SP\" // ) result == goodAddress // res10: Boolean = true // an ErrorTree is a 'many to many' relationship, the same error // can have many paths, and a path can have many errors val Validated.Invalid(errMsg) = addressCheck(badAddress) // errMsg: collection.immutable.ListMap[cats.data.NonEmptyList[List[String]], cats.data.NonEmptyList[ErrorMsg]] = ListMap( // NonEmptyList(List(), List()) -&gt; NonEmptyList(ErrorMsg(\"bad-postcode\", WrappedArray()), List()) // ) In this case the error will appear at the root of the ErrorTree. It may be that we would instead prefer the error to appear connected to the postcode property, in which case we could re-write our Rule as follows - val addressCheck2 = Rule.condAtPath[Address](\"postcode\")( _.postcode.matches(postcodeRegex), \"bad-postcode\" ) val Validated.Invalid(errMsg2) = addressCheck2(badAddress)"
    } ,    
    {
      "title": "Writing a journey",
      "url": "/uniform-scala/core/basic-program.html",
      "content": "Writing a basic journey To get our feet wet we’re going to start with a simple user journey that does a few things - first it will ask the user for their date of birth, secondly it will calculate the number of days the user has been alive and finally it will return their date of birth as a string. Imports You will need to import the core uniform library, and you will need cats. You do not need to import any interpreters when merely defining the journey. import ltbs.uniform._ We’re going to use the old java.time.LocalDate in our program too along with some code for formatting. This is specific to our example here and not likely needed for your project. import java.time._, format._ Journey definition Now we can create our main journey body. def dateOfBirth = for { dateOfBirth &lt;- ask[LocalDate](\"date-of-birth\") daysAlive = LocalDate.now.toEpochDay - dateOfBirth.toEpochDay _ &lt;- tell[Long](\"days-alive\", daysAlive) } yield dateOfBirth.format( DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL) ) Notice that this is very similar to a tagless final program. The journey itself defines the user-journey or interaction you wish to model. It is completely abstract at this point and the interpreter gets to decide how to represent the questions. TODO: Why do we need to import cats or higher kinds here?"
    } ,    
    {
      "title": "Branching",
      "url": "/uniform-scala/core/branching.html",
      "content": "Any logic you can use in Scala to branch can also be applied to Uniform journeys. when, unless and their monoid variants provide convenient shorthand for some common interactions. Branching If no steps in a journey are dependent upon the result of a previous one then using a for comprehension may be overkill and you may prefer using cats.Applicative instead - import ltbs.uniform._ import cats.implicits._ case class Person(name: String, age: Int) def askPerson(id: String) = ( ask[String](s\"$id-name\"), ask[Int](s\"$id-age\") ).tupled (askPerson(\"sender\"), askPerson(\"receiver\")).tupled But lets suppose we want an optional third Person in our tuple, and we want to use branching - ( askPerson(\"sender\"), askPerson(\"receiver\"), ask[Boolean](\"use-cc\") flatMap { case true =&gt; askPerson(\"cc\") map {_.some} case false =&gt; pure(none[Person]) } ).tupled In this case the journey would ask the user the same 4 questions initially as senderAndReceiverApplicative, however it would then ask the user for a Boolean. If they answer no then the journey would end with _3 being None. If the user picked yes however then they would be asked again for a name and age and this time _3 would be defined (Some). This could be used for all sorts of branching - you are not confined to booleans, or to using pattern matching. def bigSpender = for { spendAny &lt;- ask[Boolean](\"spendAny\") spendAmount &lt;- if (spendAny) { ask[Int](\"spendAmount\") } else { pure(0) } optSpender &lt;- if (spendAmount &gt; 100000) ( ask[String](\"name\"), ask[Int](\"age\") ).mapN(Person).map{_.some} else pure(none[Person]) } yield optSpender Simplified branching The specific use-case of using a Boolean to control an Option comes up a lot, so uniform offers a special syntax for it. when when is a construct that can take either a Boolean directly or a interaction that returns a Boolean (such as ask[Boolean]). Used directly with a boolean it emits an option in the same behaviour as optSpender above - that is it returns a Some[A] where when the predicate is true, and a None when the predicate is false. when will short-circuit the journey and not execute the ask[A] in the event that the predicate returns false. for { add &lt;- ask[Boolean](\"add-person\") person &lt;- ask[Person](\"person\") when add } yield person When taking a journey that returns a boolean the approach is the same but essentially it does not need an intermediary variable - ask[Person](\"person\") when ask[Boolean](\"add-person\") unless unless is just when but with the predicate inverted. sealed trait Booze case object Beer extends Booze case class Martini(olive: Boolean) extends Booze ask[Booze](\"choose-drink\") unless ask[Int](\"age\").map(_ &lt; 18) emptyWhen and emptyUnless Similar to when and unless is emptyWhen and emptyUnless, this however only works if the datatype you are asking for is a Monoid, in which case it will give empty instead of None. The return datatype is kept the same as the underlying ask. For example - ask[Int](\"hoursWorked\") emptyWhen ask[Boolean](\"retired\") We can apply this in the context of our earlier program in order to simplify the code - def bigSpender2 = for { spendAmount &lt;- ask[Int](\"spendAmount\") emptyUnless ask[Boolean](\"spendAny\") optSpender &lt;- ( ask[String](\"name\"), ask[Int](\"age\") ).mapN(Person) when (spendAmount &gt; 100000) } yield optSpender"
    } ,    
    {
      "title": "Composing journeys",
      "url": "/uniform-scala/core/composition.html",
      "content": "Steps in a uniform journey can be mapped over and flatMapped together. Composing journeys together A journey is simply a composition of steps (such ask, tell, interact or end) using the same semantics as monads such as Option or List that you are already familiar with in Scala. Lets start with a simple example that collects two Person records from a user. We can simply put the two ask calls together in a for comprehension. import ltbs.uniform._ case class Person(name: String, age: Int) def senderAndReceiver1 = for { sender &lt;- ask[Person](\"sender\") receiver &lt;- ask[Person](\"receiver\") } yield (sender, receiver) This is fine, but if we wanted to ask the user for the name and age separately we would have some duplication in our code. def senderAndReceiver2 = for { senderName &lt;- ask[String](\"sender-name\") senderAge &lt;- ask[Int](\"sender-age\") receiverName &lt;- ask[String](\"receiver-name\") receiverAge &lt;- ask[Int](\"receiver-age\") } yield ( Person(senderName, senderAge), Person(receiverName, receiverAge) ) Fortunately it is easy to create subjourneys and compose them into a larger journey. We can separate out the collection of the person record into a local function - def askPerson(id: String) = for { name &lt;- ask[String](s\"$id-name\") age &lt;- ask[Int](s\"$id-age\") } yield Person (name, age) def senderAndReceiver3 = for { sender &lt;- askPerson(\"sender\") receiver &lt;- askPerson(\"receiver\") } yield (sender, receiver)"
    } ,    
    {
      "title": "Controllers",
      "url": "/uniform-scala/interpreter-play27/controllers.html",
      "content": "Controllers If you have a controller you wish to use uniform with, you must first extend the PlayInterpreter[Html] where Html is some play writeable type (for our example we’ll use play.twirl.api.Html, but you could use ScalaTags or any other representation you wish) There are a few things we will need to configure before we can use our controller. Lets start with a simple journey like so - import ltbs.uniform._ val journey = for { a &lt;- ask[Int](\"a\") b &lt;- interact[String](\"b\", a) } yield (b) Routes file In order to hook this into a controller we first need to set up our routes file - GET /journey/ controllers.SimpleController.simpleAction(id = \"\") GET /journey/*id controllers.SimpleController.simpleAction(id: String) POST /journey/ controllers.SimpleController.simpleAction(id = \"\") POST /journey/*id controllers.SimpleController.simpleAction(id: String) We need to capture all the GETS and the POST’s, and direct them through to the same controller action. The routing between pages within the journey is handled by uniform itself. Simple controller In order for a controller to interpret a uniform journey it mush mix in the PlayInterpreter[A] where A is the type you want to use for HTML rendering (such as play.twirl.api.Html or scalatags.Text.all.Tag if you’d prefer to use scalatags). A simple example using twirl could look something like this - import cats.implicits._ import ltbs.uniform._, common.web._, interpreters.playframework._, validation._ import play.api.mvc._ import play.twirl.api.Html // in order to interpret our journey we need to be able to // ask the user for an Int (step a), and present the user // with an Int while asking them for a String (step b) implicit def askInt: WebInteraction[Html,Unit,Int] = ??? implicit def interactIntString: WebInteraction[Html,Int,String] = ??? class SimpleController( implicit ec: scala.concurrent.ExecutionContext, val controllerComponents: ControllerComponents ) extends BaseController with PlayInterpreter[Html] { // i18n - we can get messages from several sources and combine them // together. // In this example we first use the messages provided by the play // framework then fall back to using the 'best guess' algorithm implicit def messages( implicit request: Request[AnyContent] ): UniformMessages[Html] = { messagesApi.preferred(request).convertMessages() |+| UniformMessages.bestGuess }.map(Html.apply) // How should we 'wrap' the generated form? // If we're using twirl we would likely pass these values into // a regular page template that contains our branding, JS, etc. def pageChrome( key: List[String], errors: ErrorTree, formHtml: Option[Html], breadcrumbs: List[String], request: Request[AnyContent], messages: UniformMessages[Html] ): Html = ??? // our main controller method def simpleAction(stepId: String) = Action.async { implicit request: Request[AnyContent] =&gt; // how should we store the data between pages? // In this example we retain the data in the users session. implicit val persistence: PersistenceEngine[Request[AnyContent]] = SessionPersistence(\"simple\") // interpret the journey into a WebMonad val wm: WebMonad[Html,String] = interpret(journey) // run the WebMonad using the stepId and implicit request wm.runSync(stepId){ onCompletion: String =&gt; // what should we do upon completion of the journey? Ok(s\"Done: ${onCompletion}\") } } } The PlayInterpreter trait provides the interpret method that will return a WebMonad. The WebMonad can then be run, and will return the Future[Action]. There are two methods you can use here - run or runSync (which allows you to instead return a Future[Action] in the block of code to execute on completion. Internationalisation We need to tell Uniform where to get messages (i18n messages) from. Because Uniform is interpreter-agnostic it does not use Play messages automatically as you may wish to share messages between different interpreters. You can however access the Play Framework messages file as shown above. If you do not use a fallback as shown you will get an exception thrown when attempting to access content that is not defined - this may be desirable (for example when testing all content is translated to the target language). Apart from the ability to convert the play messages file UniformMessages behaves the same in the Play Interpreter as described in the core. WebInteraction In order for our example to work we will also have to tell our interpreter how to render forms and encode values. Although you can construct a WebInteraction directly, typically we would define a WebAsk instance for the basic types (Strings, Ints, Booleans, etc). This is covered in more detail in the common code section, but a basic example for a string datatype is as follows - implicit val stringField = new WebAsk[Html,String] { // we need to turn serialized Input (a representation // of our POST request) into our desired data type def decode(out: Input): Either[ErrorTree,String] = out.toStringField().toEither // we need to turn our data type back into its serialized // format def encode(in: String): Input = Input.one(List(in)) // how to render a Html form def render( pageKey: List[String], fieldKey: List[String], tell: Option[Html], path: Breadcrumbs, data: Input, errors: ErrorTree, messages: UniformMessages[Html] ): Option[Html] = Some{ val existingValue: String = decode(data).toOption.getOrElse(\"\") ??? // we might want to use a twirl view to produce the resulting Html } } Often we will want to have uniform create WebAsk instances for us automatically. For this purpose we can use InferWebAsk to generate forms and codecs for more complex datatypes via typeclass derivation. In addition to the WebAsk instances there are also WebTells. These are comparatively simple (as no codec is needed) - implicit val tellInt = new WebTell[Html, Int] { def render( in: Int, key: String, messages: UniformMessages[Html] ): Option[Html] = ??? } An implicit WebTell[Html,T] and an implicit WebAsk[Html,A] can combine to produce an implicit WebInteraction[Html,T,A] for consumption by the interpreter. old!!! old!!! old!!! Selection of fields Sometimes we may want to offer the user a choice between several fields or sets of fields. For example an Either[String,Int] or a sealed trait hierarchy. In this situation you may want to use Javacript to control hiding and revealing form elements, perhaps toggled by radio buttons. The selectionOfFields method takes a list of options and a function to control the Html that should be presented when that option is active. def selectionOfFields( inner: List[( String, (List[String], Path, Input, ErrorTree, UniformMessages[Html]) =&gt; Html )] )( key: List[String], path: Path, values: Input, errors: ErrorTree, messages: UniformMessages[Html] ): Html = ??? Invoking a journey We also need an actual action that will invoke the journey. def myjourney(targetId: String) = Action.async { implicit request: Request[AnyContent] =&gt; // interpret our journey using the play interpreter val playJourney = myJourney( new FuturePlayInterpreter[TellTypes, AskTypes], ) // Run the journey using the request and the targetId run(playJourney, targetId){ output =&gt; // final code to be run upon successful completion // of the journey println(output) Future.successful(Ok(\"Completed\")) } } In our routes file we would write something like this - GET /myjourney/ controllers.ExampleController.myjourney(id = \"\") GET /myjourney/*id controllers.ExampleController.myjourney(id: String) POST /myjourney/ controllers.ExampleController.myjourney(id = \"\") POST /myjourney/*id controllers.ExampleController.myjourney(id: String) Putting it all together Combining these elements we get an outline of our interpreter setup import ltbs.uniform._, interpreters.playframework._ import play.api.i18n.{Messages =&gt; _, _} import play.api.mvc._ import play.twirl.api.{Html, HtmlFormat} class ExampleController ( implicit val messagesApi: MessagesApi, ec: concurrent.ExecutionContext ) extends PlayInterpreter[Html] with I18nSupport { def messages( request: Request[AnyContent] ): UniformMessages[Html] = UniformMessages.bestGuess.map(HtmlFormat.escape) def pageChrome( key: List[String], errors: ErrorTree, tell: Html, ask: Html, breadcrumbs: Path, request: Request[AnyContent], messages: UniformMessages[Html] ): Html = ??? def selectionOfFields( inner: List[( String, (List[String], Path, Input, ErrorTree, UniformMessages[Html]) =&gt; Html )] )( key: List[String], path: Path, values: Input, errors: ErrorTree, messages: UniformMessages[Html] ): Html = ??? def myjourney(targetId: String) = Action.async { implicit request: Request[AnyContent] =&gt; // interpret our journey using the play interpreter val playJourney = myJourney( new FuturePlayInterpreter[TellTypes, AskTypes], ) // Run the journey using the request and the targetId run(playJourney, targetId){ output =&gt; // final code to be run upon successful completion // of the journey println(output) Future.successful(Ok(\"Completed\")) } } }"
    } ,    
    {
      "title": "Asking",
      "url": "/uniform-scala/core/convert.html",
      "content": "asks def ask[A](stepId: String): F[A] Whereas a tell represents sending typed information to the user an ask is the reverse - it represents prompting the user to supply some data."
    } ,    
    {
      "title": "Derivation of views",
      "url": "/uniform-scala/common-web/derivation-of-views.html",
      "content": "Instances of WebAsk for compound types can be derived from instances of its components derivation of views One of the major strengths of using Uniform for web development is that the generic web interpreter can automatically define how a form should be visually represented and encoded and persisted for you. If you define a WebAsk[Html, A] and a WebAsk[Html, B] along with a few simple rules to define composition you can have for free WebAsk[Html,(A,B)], WebAsk[Html,Either[A,B]], or WebAsk[Html,C] where C is any combination of A and B. import ltbs.uniform._, common.web._ // we'll use this as a simple representation // of HTML, in practice you'd use something more // substantial like scalatags `Tag` or twirl `Html` case class Html(value: String) // Implement InferWebAsk object MyWidgets extends InferWebAsk[Html] { // define how to render a product // (f.e. using a fieldset) def renderAnd( pageKey: List[String], fieldKey: List[String], tell: Option[Html], breadcrumbs: Breadcrumbs, data: Input, errors: ErrorTree, messages: UniformMessages[Html], members: Seq[(String, Html)] ): Html = ??? // define how to render a coproduct // (f.e. using radio buttons) def renderOr( pageKey: List[String], fieldKey: List[String], tell: Option[Html], breadcrumbs: Breadcrumbs, data: Input, errors: ErrorTree, messages: UniformMessages[Html], alternatives: Seq[(String, Option[Html])], selected: Option[String] ): Html = ??? // define a few simple primative types implicit def askInt : WebAsk[Html, Int] = ??? implicit def askString : WebAsk[Html, String] = ??? implicit def askBool : WebAsk[Html, Boolean] = ??? } Once you have an implementation of InferWebAsk you can use it to provide derived types - import MyWidgets._ implicit def askTuple: WebAsk[Html, (Int, Boolean)] = implicitly sealed trait One case class Two(a: String, b: Boolean) case class Three(a: String, c: Either[Boolean, Int]) implicit def askHierarchy: WebAsk[Html, One] = implicitly What this means in effect is that in return for a little bit of up-front work in defining the way fields should be composed together you gain the ability to manipulate the data structures at will and have the interface adapt itself. This is valuable at all points through the product lifecycle but particularly so during prototyping."
    } ,    
    {
      "title": "Play Framework Interpreter",
      "url": "/uniform-scala/interpreter-play27/",
      "content": "The play framework interpreter is a specialised form of the generic web interpreter. Play framework interpreter The play framework interpreter takes a uniform journey and converts it into a series of web pages. It can be used in conjunction with Play 2.5, 2.6, 2.7, 2.8 and it can be retrofitted into an existing play application. As the web application developer you are free to mix and match conventional journeys with uniform journeys as you see fit. Installation/Integration In addition to the normal setup you will need to import the play interpreter. libraryDependencies += \"com.luketebbs.uniform\" %% \"interpreter-play26\" % \"{{ site.last-stable-version }}\" Composition/Separation The simplest setup is just to define your journey inside the same project as the controllers themselves, however it is good practice to separate concerns and keep the journey separate from the implementation. For example you could have a multi-project build structured as follows - - my-project - build.sbt - journey - src/main/scala - Journey.scala - src/test/scala - LogicTableBasedTests.scala (optional) - play-implementation - app/controllers - MyController.scala - other-subproject (optional) Under this setup the journey sub-project would be set up to use uniform core, whereas the play-implementation sub-project would be a play application that has dependsOn(journey) in its config. This means you are not tied into the play framework and you could build a play implementation in parallel with one or more other implementations."
    } ,    
    {
      "title": "Web Interpreters",
      "url": "/uniform-scala/common-web/",
      "content": "Generic Web Interpreters Uniform provides interpreters that target several web development frameworks, and they all inherit from a generic web interpreter. There is no need to import the generic component unless you are building your own interpreter as it will be imported automatically by whatever web interpreter you choose to utilise. Therefore please see the relevant section for install instructions."
    } ,    
    {
      "title": "Home",
      "url": "/uniform-scala/",
      "content": "uniform uniform is a scala Embedded Domain-specific Language (eDSL) for defining, in abstract terms, an interaction with a user. This definition can then be used with one or more interpreters to do useful things such as - provide a Play Framework journey construct a Logic Table showing input and output compile a Javascript-only interface"
    } ,    
    {
      "title": "Interacting",
      "url": "/uniform-scala/core/interacts.html",
      "content": "An interact is a single step in a Uniform journey that both presents information to and requests information from the user simultaneously. Interacting interact is simply the combination of an ask and a tell together into a single step. In fact we can consider both ask and tell to be specialised forms of interact. It has a type parameter for both the datatype being presented to the user (Tell) and being asked of the user (Ask). A confirmation page presenting a user with an address and asking them for a Yes/No answer could be modeled as interact[Address, Boolean](\"confirm-address\", addr). Relationship with ask and tell Recall that a uniform step has three type parameters - Tracks the types used throughout the whole journey The type the user is being told (Unit in case of ask) The type the user is being told (Unit in case of tell) Using some simplified pseudocode and ignoring the 1st type paramater we can see that both ask and tell can be considered as being defined in terms of interact - def interact[T,A](stepId: String, value: T): Uniform[T, A] def tell[T](stepId: String, value: T): Uniform[T, Unit] = interact[T, Unit](stepId, value) def ask[A](stepId: String): Uniform[Unit, A] = interact[Unit, A](stepId, ()) ask is simply an interact with no data being presented to the user, and tell is just an interact with no data being requested of the user. We will actually see this when we look at the type signatures of ask and tell - import ltbs.uniform._ val aTell: Uniform[ Needs.Interact[Int, Unit], Int, // 'input' type Unit // 'output' type ] = tell(\"tell\", 123) val anAsk: Uniform[ Needs.Interact[Unit, String], Unit, String ] = ask[String](\"ask\") val anInteract: Uniform[ Needs.Interact[Option[Long], Boolean], Option[Long], Boolean ] = interact[Boolean](\"interact\", Option(0L)) val composition: Uniform[ Needs.Interact[Int, Unit] with Needs.Interact[Unit, String] with Needs.Interact[Option[Long], Boolean], Int with Unit with Option[Long], (String, Boolean) ] = for { _ &lt;- aTell as &lt;- anAsk in &lt;- anInteract } yield (as, in)"
    } ,    
    {
      "title": "Internationalisation",
      "url": "/uniform-scala/interpreter-play27/internationalisation.html",
      "content": "Play Messages can be converted to UniformMessages, or mixed in with other providers. Internationalisation It is possible to convert the play messages into UniformMessages like so - import ltbs.uniform._, interpreters.playframework._ import play.api.mvc._ import play.twirl.api._ def messagesApi: play.api.i18n.MessagesApi = ??? def messages(request: Request[AnyContent]): UniformMessages[Html] = messagesApi.preferred(request).convertMessages.map{HtmlFormat.escape}"
    } ,    
    {
      "title": "Internationalisation",
      "url": "/uniform-scala/common-web/internationalisation.html",
      "content": "Uniform provides several mechanisms for localised content that can be swapped or combined. Internationalisation Messages are provided as a UniformMessages[Html] object, where Html is the data-type that composes the response (such as play.twirl.api.Html if you’re using twirl with the Play Framework). Under this configuration an exception will be thrown if a non-existant key is asked for. UniformMessage is a Monoid, and as such can be combined messages easily - the left-hand source will be consulted first and if a message is not found the right-hand instance will be asked. If we want the key itself to be returned when there is no message defined the UniformMessages.echo provider can be used as a fallback - def messages2(request: Request[AnyContent]): UniformMessages[Html] = { messagesApi.preferred(request).convertMessages() |+| UniformMessages.echo } map ( HtmlFormat.escape ) A nice path for development is to use UniformMessages.bestGuess as a fallback. You may want to run with UniformMessages.attentionSeeker if you are a content author in order to display all optional content on the page."
    } ,    
    {
      "title": "Internationalisation",
      "url": "/uniform-scala/core/internationalisation.html",
      "content": "Internationalisation Messages are provided as a UniformMessages[Html] object, where Html is the data-type that composes the response (such as play.twirl.api.Html if you’re using twirl with the Play Framework). Under this configuration an exception will be thrown if a non-existant key is asked for. UniformMessage is a Monoid, and as such can be combined messages easily - the left-hand source will be consulted first and if a message is not found the right-hand instance will be asked. If we want the key itself to be returned when there is no message defined the UniformMessages.echo provider can be used as a fallback - def messages2(request: Request[AnyContent]): UniformMessages[Html] = { messagesApi.preferred(request).convertMessages() |+| UniformMessages.echo } map ( HtmlFormat.escape ) A nice path for development is to use UniformMessages.bestGuess as a fallback. You may want to run with UniformMessages.attentionSeeker if you are a content author in order to display all optional content on the page."
    } ,    
    {
      "title": "CLI Interpreter",
      "url": "/uniform-scala/interpreter-cli/interpreter-cli.html",
      "content": "CLI Interpreter Probably the simplest implementation of an interactive user interface is a text-only, monolingual command-line application. We’re unlikely to use this in production, but it can form an extremely cheap-but-cheerful way to explain or verify logic or user journeys with stakeholders in the early stages of a project. Because of its simplicity it is also a great way to see the fundamentals of uniform in action. Starting with a program First of all you need a program. Lets start with a simple greeting application - import ltbs.uniform._ import cats.implicits._ import scala.language.higherKinds type TellTypes = NilTypes type AskTypes = String :: NilTypes def helloProgram[F[_] : cats.Applicative]( interpreter: Language[F, TellTypes, AskTypes] ): F[String] = { import interpreter._ ( ask[String](\"forename\"), ask[String](\"surname\") ).mapN(\"Hello \" + _ + \" \" + _) } Notice we are only using a single data type here - String. While you can have as many data-types as you want in your program each interpreter needs to understand how to handle that data-type before it can operate on your program. Generally therefore it’s best to start off with just a few basic data-types and add more specialisation as you go. Some interpreters (such as the Play interpreter) will infer compound data-types, but the CLI interpreter does not have this capability at present. Importing the interpreter We need to add an extra import to include the new interpreter - libraryDependencies += \"com.luketebbs.uniform\" %% \"interpreter-cli\" % \"{{ site.last-stable-version }}\" Running the program We need to import the interpreter - import ltbs.uniform.interpreters.cli._ The program can now be executed using the interpreter. If invoked helloProgram will now prompt the user for a forename, then a surname and then give the expected greeting. def runner = helloProgram(new CliInterpreter[TellTypes, AskTypes])"
    } ,    
    {
      "title": "Logic Table Interpreter",
      "url": "/uniform-scala/interpreter-logictable/interpreter-logic-table.html",
      "content": "Logic Table Interpreter The logic table interpreter is another very simple interpreter. Put simply if given a series of values for the questions a user would be asked it shows the interactions the user would experience and the final output of the program upon completion. Despite being simple the logic table interpreter is however quite useful as can be readily hooked into unit tests or converted into a spreadsheet to be shown to stakeholders or Business Analysts. Starting with a program For this example we will write a deliberately convoluted program in order to test the logic - import ltbs.uniform._ import cats.implicits._ import scala.language.higherKinds type Money = Int type AskTypes = Int :: Boolean :: NilTypes type TellTypes = NilTypes def greasySpoon[F[_]: cats.Monad]( interpreter: Language[F, TellTypes, AskTypes] ) : F[Money] = { import interpreter._ for { age &lt;- ask[Int](\"age\") food &lt;- ask[Boolean](\"wantFood\") tea &lt;- ask[Boolean](\"wantTea\") baconCost &lt;- ask[Int](\"bacon\").map(_ * 12) emptyUnless food eggsCost &lt;- ask[Int](\"eggs\").map(_ * 24) emptyUnless food foodCost = baconCost + eggsCost teaCost &lt;- ask[Int](\"sugar\").map(_ * 10 + 50) emptyUnless tea youngDiscount = if (age &lt; 16) teaCost / 10 else 0 oldDiscount = if (age &gt; 60) (teaCost + foodCost) * (Math.min(age - 60,25) / 100) else 0 } yield (foodCost + teaCost + youngDiscount + oldDiscount) } So we have a program for a fastfood restaurant. The user is first asked for their age, then if they want food and if they want tea. They are charged 12 pence per slice of bacon (or 12 pounds if you are in Shoreditch - I’ll leave it to the user to determine the currency), 24p per egg, 50p for a mug of tea plus 10p per dose of sugar. Finally young customers get 10% off tea and older customers get 1% off both food and drink per year over 60 up to a maximum of 25%. We want to test - The user is asked the correct questions (only being asked about food if we say we want food, for example) The calculations are correct Obviously this is rather silly - normally we would extract the calculation logic out into a function, but for the sake of illustrating the testing we will leave the financial code tangled into our user-interaction program. Setup We need to add an extra import to include the new interpreter - libraryDependencies += \"com.luketebbs.uniform\" %% \"interpreter-logictable\" % \"{{ site.last-stable-version }}\" And we need to import the logictable library - import ltbs.uniform.interpreters.logictable._ Providing sample input We now need to provide some sample data for the interpreter to consume. implicit val intSamples = new SampleData[Int] { def apply(key: String): List[Int] = key match { case \"age\" =&gt; List(10,50,100) case _ =&gt; List(1,2,3) } } implicit val booleanSamples = new SampleData[Boolean] { def apply(key: String): List[Boolean] = List(true, false) } We can now execute our program with the logic table interpreter - val output: List[(List[String], Either[ErrorTree,Int])] = greasySpoon( new LogicTableInterpreter[TellTypes, AskTypes] ).value.run // output: List[(List[String], Either[ErrorTree, Int])] = List( // ( // List( // \"age ask: 10\", // \"wantFood ask: true\", // \"wantTea ask: true\", // \"bacon ask: 1\", // \"eggs ask: 1\", // \"sugar ask: 1\" // ), // Right(102) // ), // ( // List( // \"age ask: 10\", // \"wantFood ask: true\", // \"wantTea ask: true\", // \"bacon ask: 1\", // \"eggs ask: 1\", // \"sugar ask: 2\" // ), // Right(113) // ), // ( // List( // \"age ask: 10\", // \"wantFood ask: true\", // \"wantTea ask: true\", // \"bacon ask: 1\", // \"eggs ask: 1\", // \"sugar ask: 3\" // ), // Right(124) // ), // ( // List( // \"age ask: 10\", // \"wantFood ask: true\", // \"wantTea ask: true\", // \"bacon ask: 1\", // \"eggs ask: 2\", // \"sugar ask: 1\" // ), // Right(126) // ), // ( // List( // \"age ask: 10\", // \"wantFood ask: true\", // ... The output is a complex type at first glance, but what this represents is the list of question the user would be asked with the answer they gave paired with the outcome (either an error or a completed journey result). output.take(5).foreach{ case (messages, outcome) =&gt; println(messages.mkString(\"\\n\")) println(s\" =&gt; $outcome\") } // age ask: 10 // wantFood ask: true // wantTea ask: true // bacon ask: 1 // eggs ask: 1 // sugar ask: 1 // =&gt; Right(102) // age ask: 10 // wantFood ask: true // wantTea ask: true // bacon ask: 1 // eggs ask: 1 // sugar ask: 2 // =&gt; Right(113) // age ask: 10 // wantFood ask: true // wantTea ask: true // bacon ask: 1 // eggs ask: 1 // sugar ask: 3 // =&gt; Right(124) // age ask: 10 // wantFood ask: true // wantTea ask: true // bacon ask: 1 // eggs ask: 2 // sugar ask: 1 // =&gt; Right(126) // age ask: 10 // wantFood ask: true // wantTea ask: true // bacon ask: 1 // eggs ask: 2 // sugar ask: 2 // =&gt; Right(137)"
    } ,    
    {
      "title": "Interpreters",
      "url": "/uniform-scala/interpreters.html",
      "content": "Interpreters A uniform program is processed by one or more interpreters to give a useful output. Currently working A simple Command-Line Interpreter A Logic-table interpreter that is useful for unit-testing and early exploratory work. An interpreter that produces controllers for the Play Framework A static site interpreter that outputs the logic as Javascript. Useful for producing design prototypes. WIP A selenium interpreter, designed to be used in conjunction with either the play interpreter or the static site interpreter. For production of acceptance tests/taking screenshots of the user journey for given sets of input. Concepts (not started) A http4js interpreter A direct to Akka HTTP interpreter"
    } ,      
    {
      "title": "Listing Pages",
      "url": "/uniform-scala/common-web/listing-pages.html",
      "content": "Listing pages {% include_relative web-monad.md %}"
    } ,    
    {
      "title": "Persistence",
      "url": "/uniform-scala/common-web/persistence.html",
      "content": "Persistence TODO!!!"
    } ,    
    {
      "title": "Memoisation",
      "url": "/uniform-scala/common-web/remote-calls.html",
      "content": "Remote Calls in Play Care must be taken when hooking remote calls into a journey to avoid repeatedly hitting a server. For example consider this journey - import ltbs.uniform._ import cats.implicits._ import scala.language.higherKinds import scala.concurrent.Future case class User ( forename: String, surname: String, age: Int ) trait Server { def userLookup(userName: String): Future[User] def isAllowed(user: User): Future[Boolean] } case class SensitiveData(value: String) type TellTypes = SensitiveData :: NilTypes type AskTypes = String :: NilTypes def exampleJourney = for { userName &lt;- ask[String](\"username\") user &lt;- convert(\"user-lookup\",server.userLookup) _ &lt;- ( tell[SensitiveData](\"s1\", SensitiveData(\"s1\")), tell[SensitiveData](\"s2\", SensitiveData(\"s2\")), tell[SensitiveData](\"s3\", SensitiveData(\"s3\")), tell[SensitiveData](\"s4\", SensitiveData(\"s4\")) ).tupled when server.isAllowed(user) } yield (user.surname) This journey will ask the user for their username, look up their account from userLookup. It will then show the user 4 items of SensitiveData but only if they are permitted according to isAllowed. Lets assume we have a Server[Future] instance that calls our server and returns a response. We now need to implement a Server[WebMonad] so we can interleave these calls into our journey. We might do this as follows - import ltbs.uniform.common.web._ import ltbs.uniform.interpreters.playframework._ import play.twirl.api.Html import concurrent._ case class ServerWrapper( inner: Server[Future] )(implicit codec: Codec[User]) extends Server[WebMonad[?, Html]] { val adapter = FutureAdapter[Html] def userLookup(userName: String): WebMonad[User, Html] = adapter.rerunOnPriorStateChange(\"userLookup\")( inner.userLookup(userName) ) def isAllowed(user: User): WebMonad[Boolean, Html] = adapter.alwaysRerun(inner.isAllowed(user)) } FutureAdapter provides access to natural transformations of the type Future ~&gt; WebMonad, but how you want the logic to execute is probably contextual. Lets assume we don’t want to overload the server by lots of needless calls to userLookup, but if the user goes back to the ‘username’ step and changes their answer we then want to abandon the cached User and call the server again. For this purpose the rerunOnPriorStateChange method gives us what we need - it takes a checksum of the state of the previous pages and will only call the inner method again if the checksum changes. However it is possible that an administrator revokes access to a user after they have gone past the ‘username’ page, in which case caching the result would be a bad thing. For this purpose we may decide we’re happy to trade a bit more load to the server in return for better security. In this case using alwaysRerun would cause the user to be unable to advance from ‘s1’ to ‘s2’ (for example) even if they had access at the start of the journey because isAllowed runs again for each step after its position in the journey."
    } ,    
    {
      "title": "Remote Calls",
      "url": "/uniform-scala/core/remote-calls.html",
      "content": "Remote Calls convert and convertWithKey allow other higher-kinded types to be interleaved into a journey. Sometimes it is necessary to perform some sort of out-of-band interaction during a journey, for example it might be that you need the user to input a code and you need to call an API to look up a value based upon that code. To illustrate this with an example let us take the journey to calculate the number of days a person has been alive from earlier - import ltbs.uniform._ import java.time._, format._ def dateOfBirth = for { dateOfBirth &lt;- ask[LocalDate](\"date-of-birth\") daysAlive = LocalDate.now.toEpochDay - dateOfBirth.toEpochDay _ &lt;- tell[Long](\"days-alive\", daysAlive) } yield dateOfBirth.format( DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL) ) If we wanted to modify this such that the calculation for daysAlive is done via some remote process we can instead define a ‘server’ like so - import scala.concurrent.Future trait Server { def calculate(dob: LocalDate): Future[Long] } We can now pass the server as a parameter into the function. In order to adapt the Future to whatever type we end up interpreting to we can use the convert method - def dateOfBirthRemote(server: Server) = for { dateOfBirth &lt;- ask[LocalDate](\"date-of-birth\") daysAlive &lt;- convert(server.calculate(dateOfBirth)) _ &lt;- tell[Long](\"days-alive\", daysAlive) } yield dateOfBirth.format( DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL) ) In this case we now call our server in our program. We must now provide a server instance when calling dateOfBirthRemote Converters Our interpreter will need to know how to handle the conversion from a Future (in the case of our example) to whatever higher-kinded type the interpreter uses. For example, suppose our interpreter targets the Option higher-kinded type. We would need to show how to convert a Future[LocalDate] into a Option[LocalDate]. Many interpreters will ship with support for common datatypes (for example the generic web interpreter provides support for converting Future into WebMonad). If you have to provide your own conversion method, there are three main ways to do it. Using a natural transformation The most generic way to show the interpreter how to handle the conversion is to provide a natural transformation (for example Future ~&gt; Option) in implicit scope. In this instance the same logic will be applied for converting a Future[LocalDate] to a Option[LocalDate] as would be used to convert a Future[Customer] to a Option[Customer] import cats.~&gt; implicit val converterOne = new (Future ~&gt; Option) { def apply[A](in: Future[A]): Option[A] = ??? } Once this instance is in scope you will be able to interpret any journey that uses convert from a Future with an interpreter targeting Option. Using a function This method provides a more fine-grained control than using natural transformations. For example if we wanted to use different logic for converting a LocalDate as for a Customer we could instead define an implicit function from one type to the other. case class Customer(name: String, age: Int) implicit def f: Function[Future[LocalDate],Option[LocalDate]] = ??? implicit def f2: Function[Future[Customer],Option[Customer]] = ??? Using a keyed and typed converter This approach provides the most flexibility but is the least generic. In this instance we can control the logic for the conversion not only based upon types but also based upon the step ID. In order to get a step ID we need to provide one in our journey using the convertWithKey function - def dateOfBirthRemoteStepped(server: Server) = for { dateOfBirth &lt;- ask[LocalDate](\"date-of-birth\") daysAlive &lt;- convertWithKey(\"remote-call-dob\")( server.calculate(dateOfBirth) ) _ &lt;- tell[Long](\"days-alive\", daysAlive) } yield dateOfBirth.format( DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL) ) We can now implement a Converter, and use the step ID to discern between “remote-call-dob” and any other similar call. implicit val converter = new Converter[Future, Option, LocalDate] { def apply( key: String, in: () =&gt; Future[LocalDate] ): Option[LocalDate] = key match { case \"remote-call-dob\" =&gt; ??? case _ =&gt; ??? } } We often use this third approach when we need to encode and cache the result (for example with web interpreters)."
    } ,      
    {
      "title": "Setup",
      "url": "/uniform-scala/setup.html",
      "content": "Installation - core uniform only If you just want to write an abstract program in uniform and either you will be creating your own interpreter or you want to release the program in a separate jar file to where it will be executed then you only need the core dependency in your build.sbt - libraryDependencies += \"com.luketebbs.uniform\" %% \"core\" % \"{{ site.last-stable-version }}\" Or if you’re using ScalaJS - libraryDependencies += \"com.luketebbs.uniform\" %%% \"core\" % \"{{ site.last-stable-version }}\" Extra steps for Scala 2 (2.10, 2.11, 2.12, 2.13) If you’re using Scala 2 you can save yourself a lot of pain by using the kind projector compiler plugin - addCompilerPlugin(\"org.spire-math\" %% \"kind-projector\" % \"0.9.3\") You will also need partial unification enabled - scalacOptions += \"-Ypartial-unification\" Adding an interpreter A program by itself is not much use without an interpreter to execute it. Uniform also provides several ready-to-use interpreters out-of-the-box for you to experiment with - libraryDependencies += \"com.luketebbs.uniform\" %% \"interpreter-play26\" % \"{{ site.last-stable-version }}\""
    } ,    
    {
      "title": "Subjourneys and loops",
      "url": "/uniform-scala/core/subjourney.html",
      "content": "subjourney group steps together inside a journey. askList allows a subjourney to loop, returning multiple items. subjourneys It is possible to group a series of steps into a subjourney with its own step ID. import ltbs.uniform._ case class Customer(username: String, age: Int) case class Order(customer: Customer, units: Int) def placeOrder = for { customer &lt;- subJourney(\"customer\") { for { u &lt;- ask[String](\"username\") a &lt;- ask[Int](\"age\") } yield Customer(u,a) } units &lt;- ask[Int](\"number-of-units\") } yield Order(customer, units) In effect the step ID’s are hierarchical, rather than flat, however it is entirely at the discretion of the interpreter as to how subjourneys should be handled. For example a web-based interpreter may choose to create a URL for the username page under /customer/username, whereas a CLI interpreter may simply flatten the hierarchy and effectively inline the subjourney. askList Consider the situation where you want to ask for a collection - case class User(name: String, age: Int) def journey = for { p &lt;- ask[List[User]](\"users\") _ &lt;- tell(\"confirm\", p) } yield p Now imagine that you want to separate out asking for the name and age into separate stages, but still returning List[User]. For this purpose you can use askList. def journey2 = for { p &lt;- askList[User](\"users\") { case (_: Option[Int], _: List[User]) =&gt; for { name &lt;- ask[String](\"name\") age &lt;- ask[Int](\"age\") } yield User.apply(name, age) } _ &lt;- tell(\"confirm\", p) } yield p There is no interact equivalent for askList as the interaction will typically involve showing the user the collection as the user constructs it. Additionally as the interpreter may provide the mechanism to edit a record you may wish to pre-populate the steps with values from the collection. For this purpose you can access the index of the record being edited (or None if the user is adding a record), and the collection of records already in the collection. def journey3 = for { p &lt;- askList[User](\"users\") { case (editIndex: Option[Int], existing: List[User]) =&gt; val editRecord = editIndex.flatMap(existing.lift) for { name &lt;- ask[String](\"name\", default = editRecord.map(_.name) ) age &lt;- ask[Int](\"age\", default = editRecord.map(_.age) ) } yield User.apply(name, age) } _ &lt;- tell(\"confirm\", p) } yield p You could also use this for cross-record validation - import ltbs.uniform.validation.Rule def journey4 = for { p &lt;- askList[User](\"users\") { case (editIndex: Option[Int], existing: List[User]) =&gt; val editRecord = editIndex.flatMap(existing.lift) for { name &lt;- ask[String](\"name\", validation = Rule.cond[String]( {n =&gt; !existing.exists(_.name == n)}, \"duplicate-name\" ), default = editRecord.map(_.name) ) age &lt;- ask[Int](\"age\", default = editRecord.map(_.age) ) } yield User.apply(name, age) } _ &lt;- tell(\"confirm\", p) } yield p"
    } ,    
    {
      "title": "Telling",
      "url": "/uniform-scala/core/tells.html",
      "content": "A tell is a step in a Uniform journey that passes information to the user. An end is a step that passes information to the user, but which they cannot continue beyond. tell A call to tell represents passing some typed data to the user. The specifics of exactly how this should be done depends upon the interpreter that is running the program and in particular how it chooses to handle that datatype. // create some data case class Story(title: String, author: String) val davidCopperfield = Story(\"David Copperfield\",\"Charles Dickens\") // construct a journey that presents the data to the user val tellAStory = tell(\"story-telling\", davidCopperfield) \"story-telling\" in this case is the step identifier - these are presented to the user but the exact form will depend upon the interpreter used. It may for example be used to construct messages telling the user which question they are answering, for forming URL’s or for persistence of data. Step identifiers should be unique to every step as otherwise the interpreters can get confused as they do not know the current place in the journey. We can gain a bit more insight into the tell operation by examining the type signature - val anInspectorCalls = Story(\"An Inspector Calls\",\"J B Priestly\") val tellAnotherStory: Uniform[Needs.Interact[Story, Unit], Story, Unit] = tell(\"an-inspector-calls\", anInspectorCalls) The first type parameter Needs.Interact[Story, Unit] is used for tracking which types the interpreter needs to support, is discussed later on and can be ignored for the moment. The second type parameter Story is the input parameter - that is being expressed to the user. The third and final type parameter Unit is the type we are asking from the user (we’re not asking them for anything). end Closely related to tell is end, the main difference being that while the third type parameter (requested data type) of tell is always Unit the return type for end is Nothing. Unit has a cardinality of 1 - there is only one value the user may return from a tell - acknowledgement and a desire to continue. But Nothing has a cardinality of zero - there is no response the user can give at all. As a result a journey can continue after a tell, but not after an end. end’s are used at terminating points in a user interaction - for example a website may collect some information before processing an application, but it may be that the user has already applied. In this case the interaction designer may decide to use an end page to inform the user of this fact."
    } ,    
    {
      "title": "Validation",
      "url": "/uniform-scala/core/validation.html",
      "content": "Validation For any given interact[Tell, Ask] the validation data structure is List[List[Rule[Ask]]]. Each inner groups of Rules is carried out ‘concurrently’ (error accumulating) before sequentially passing validation on to the next stage (fail-fast). This means that error checking can be applied in-order, all together or some mix of the two. For example, you might want to check that a user supplies valid data on all the fields in an address. It would be annoying for the user if they corrected an error on the first field then resubmitted before seeing an error on the second field. In this case you’d want the errors to accumulate. Once all the initial checks pass you might want to then run a check afterwards, for example to ensure the address actually exists or can be delivered to. Lets start with an example with no validation at all - import ltbs.uniform._, validation._ case class Address( line1: String, line2: String, line3: String, line4: String, postcode: String ) { def lines: List[String] = List(line1, line2, line3, line4, postcode) } def askAddress1 = ask[Address](\"post-to\") We can start with a single rule, a simple regex check against a postcode - import cats.data.NonEmptyList val regex = \"^[A-Z]{1,2}\\\\d[A-Z\\\\d]? ?\\\\d[A-Z]{2}$\" val postcodeCheck = Rule.cond[Address](_.postcode.matches(regex), \"bad-postcode\") Here we have given a scenario for an error as a partial function. It is important to remember we are dealing with negatives - matching against a bad input rather than giving a predicate for a good record. The regex is used as a guard and an ErrorMsg is supplied along with a non-empty path to where on the form/input data structure the error applies. There can be several paths because in some cases the error may be applicable to several fields - if the town doesn’t match the postcode we might want to display the error on both those fields. We can now test our rule on the REPL or in a unit test - val testAddress: Address = Address( \"12 The Street\", \"Genericford\", \"Madeupshire\", \"\", \"BAD POSTCODE\" ) // testAddress: Address = Address( // \"12 The Street\", // \"Genericford\", // \"Madeupshire\", // \"\", // \"BAD POSTCODE\" // ) postcodeCheck.apply(testAddress) // res0: cats.data.Validated[collection.immutable.ListMap[NonEmptyList[List[String]], NonEmptyList[ErrorMsg]], Address] = Invalid( // ListMap( // NonEmptyList(List(), List()) -&gt; NonEmptyList(ErrorMsg(\"bad-postcode\", WrappedArray()), List()) // ) // ) If we want to apply our validation rule to a step in a journey we simply supply it as a parameter. def askAddress2 = ask[Address](\"post-to\", validation = postcodeCheck) In this case we only have a single Rule applied to the validation parameter. If we wanted to check both a postcode against a Regex and that the 1st line starts with a number we can either do this sequentially using followedBy - val sequentialChecks: Rule[Address] = postcodeCheck followedBy Rule.cond[Address](_.line1.head.isDigit, \"line-must-start-with-number\")"
    } ,    
    {
      "title": "Views",
      "url": "/uniform-scala/common-web/views.html",
      "content": "Views Different View Types Uniform is agnostic about how views are constructed. In the examples here we have used twirl Html, but you can use any representation you wish, as long as it is both Writeable and a Monoid. If you wanted to use scalatags, for example, you could do something like this - import scalatags.Text.all._ import play.api.http.{Writeable, ContentTypeOf, ContentTypes} import play.api.mvc.Codec import cats.Monoid import cats.implicits._ implicit val fragContentType: ContentTypeOf[Frag] = { ContentTypeOf[Frag](Some(ContentTypes.HTML)) } implicit def fragWriteable(implicit codec: Codec): Writeable[Frag] = { Writeable(frag =&gt; codec.encode(\"&lt;!DOCTYPE html&gt;\\n\" + frag.render)) } implicit val fragMonoid = new Monoid[Frag] { def empty: Frag = RawFrag(\"\") def combine(a: Frag, b: Frag): Frag = RawFrag(a.render + b.render) } How fields are rendered and encoded Views for compound types are produced using typeclass derivation. For example, suppose you tell the play interpreter how to construct a view for a String field like so - import ltbs.uniform._, interpreters.playframework._ implicit val scalatagsStringField = new FormField[String,Frag] { def decode(out: Input): Either[ErrorTree,String] = { val root: Option[String] = out.valueAtRoot .flatMap(_.filter(_.trim.nonEmpty).headOption) root match { case None =&gt; Left(ErrorMsg(\"required\").toTree) case Some(data) =&gt; Right(data) } } def encode(in: String): Input = Input.one(List(in)) def render( key: List[String], path: Path, data: Option[Input], errors: ErrorTree, messages: UniformMessages[Frag] ): Frag = { val existingValue: String = data.flatMap(_.valueAtRoot.flatMap{_.headOption}).getOrElse(\"\") input(`type` := \"text\", name := key.mkString(\".\")) { existingValue } } } decode is taking an Input and converting it to either a resulting correct String or an ErrorTree. Here the only built-in validation we are doing is to check the string is non-empty. Normally we would only apply the validation here to ensure that the data can be mapped to the correct type (it’s debatable as to if we should even check for non-empty here). We can always add validation to the actual pages if we want. encode takes a value and turns it back into an Input. This cannot go wrong so there is no ErrorTree. render is probably the most interesting part here - this emits some Html (a scalatags Frag in our instance here). Note here we’re not doing any special rendering based upon the error or any field labels. There is quite a lot going on in this string example. However it’s easy to produce other field types from this - implicit val scalatagsIntField: FormField[Int,Frag] = scalatagsStringField.simap(x =&gt; Either.catchOnly[NumberFormatException](x.toInt) .leftMap(_ =&gt; ErrorMsg(\"bad.value\").toTree) )(_.toString) An Int field would be almost identical to a String field - the presentation should be the same but the encode method needs to take an Int and the decode method needs to emit an Either[ErrorTree,Int]. These methods should be based upon the ones used for scalatagsStringField - we still want to check the field is non-empty before attempting to parse it into an Int but we want to append a check and conversion to the decode method. The encode method should still place the value in the correct place but we want to turn the Int into a String beforehand. The simap method (named because the transformation is a split epimorphism) allows us to prepend a method to encode (Int =&gt; String in our case) and append a flatMap transformation to decode ( String =&gt; Either[ErrorTree, Int]). How views are derived One of the main advantages of using the Uniform Play Interpreter over manually crafting journeys is that you can take advantage of the form inference, that is if you have a case class which is composed of Strings and Ints the interpreter can figure out how to display it and encode it for you. case class Person(forename: String, surname: String, age: Int) val luke = Person(\"Luke\", \"Tebbs\", 38) // normally we won't need this import when working within a // controller - object Inferer extends ltbs.uniform.common.web.InferFormField[Frag] { def selectionOfFields( inner: List[(String, (List[String], Path, Option[Input], ErrorTree, UniformMessages[Frag]) =&gt; Frag)] )( key: List[String], path: Path, values: Option[Input], errors: ErrorTree, messages: UniformMessages[Frag] ): Frag = ??? } import Inferer._ implicitly[FormField[Person, Frag]].encode(luke) Overriding views for a single page Overriding views for a whole journey Creating more complex actions"
    } ,    
    {
      "title": "WebMonad",
      "url": "/uniform-scala/common-web/web-monad.html",
      "content": "How it works - the Web Monad The uniform web interpreter is based off the observation that interaction with a web journey can be thought of as an Either[Result, A] for a given ask[A] as long as Either is right-associative monad. Given an ask[Address] we would convert that to Either[Result, Address] A Right[Result, Address] would represent that the user has supplied a value which has passed validation, in this situation we can proceed to the next step in the journey. A Left[Result, Address] could represent a number of things, but for simplicity we’ll consider the main ones as - No data submitted (render an empty form) Data submitted, validation not passed (render a populated form with an error message) Data submitted previously, form being revisited by the user (render a populated form) When running a single ask[A] we get either a new page to be rendered (a Left(someResult)) or we get a Right[A]. Because right-associative Either is a cats.Monad that captures the error context we can compose all our steps into one big Either[Result, B]. Inside our controller we invoke our program with the web interpreter. Along with the program we supply a terminating fold of the form B =&gt; Future[Result] which allows us to specify what should happen when we get to the end of the journey along with what should be sent to the user. And this is the basis of how web journeys work in Uniform. In practice we cannot encapsulate everything in an Either[Result, ?], so the actual Webmonad is closer to the following - type WebInner[A] = RWST[Future, (JourneyConfig, List[String], Request[AnyContent]), Unit, (Path, DB), A] type WebMonad[A] = EitherT[WebInner, Result, A] Our steps must be within Future in order to support scenarios where we need to call some remote process (for example to do an address lookup). The JourneyConfig reader is merely a placeholder for configuration options that may be needed in the future. The List[String] reader is used for the URL pieces, for example - http://server.com/path-to-journey/one/two/three/ =&gt; List(\"one\",\"two\",\"three\") Normally the user will move through the journey naturally (there is a redirect following a validated post), however this allows the user to explicitly give a step (for example if they want to go back in the journey and change an answer)1. The Request reader is used mainly for extracting the payload from a POST request. The Path state allows all pages to know the pages that have come before them, and can be used to create breadcrumb hyperlinks on the page. DB is an alias for Map[List[String],String] and its usage in the state is for serialising the data the user has been input. This is handled by the PersistenceEngine. Although the user can request any page they like uniform will not allow the user to bypass validation or skip pages without answering questions. &#8617;"
    } ,    
    {
      "title": "Writing Interpreters",
      "url": "/uniform-scala/core/writing-interpreters.html",
      "content": "Writing Interpreters So far we have discussed how to consume existing interpreters, this section is meant to serve as a guide as to how to write your own interpreter. This is not necessary (or recommended) for day-to-day usage of Uniform but it opens up lots of possibilities should you have somewhat unusual requirements. Unnatural Transformations Uniform journeys are essentially tagless final programs with one important twist - the methods accept type parameters. As such we can call ask[Int] rather than needing askInt, askString, etc for every possible datatype we might want to consume. If we did have hundreds of askN methods one for every possible datatype our interpreters would need to provide an implementation of every datatype we wanted, we would need to update the uniform language itself if we wanted to add a new type and therefore every interpreter (if all other users wanted to use your new datatype or not). Using ask[T]: UF[T] presents its own problems however - when using tagless final we transform our UF[T] into our desired datatype, WebMonad[T] perhaps. UF ~&gt; WebMonad is therefore the natural transformation that is being applied. But natural transformations are total - for every possible A we must be able to convert UF[A] into WebMonad[A]. Therefore the only methods we would be able to invoke for A are ones that belong to Any such as toString. Ordinarily we would add a typeclass to represent the support for a given datatype, for example ask[A: WebMonadSupport] but then our typeclasses are bound to the journey itself at compile time rather than being specific to a given interpreter. We need something that is not quite a natural transformation. Our journey should be able to refer to any datatype it needs but the typeclass instance should be owned and retrieved by the interpreter. The journey must declare the types it uses, and the interpreter must provide support for each datatype in the journey it interprets by way of a typeclass. The journey must know nothing of the typeclasses used by any given interpreter. I found this to be a surprisingly difficult problem to solve, and several techniques were explored in different versions of uniform. The four approaches I found were - use the Eff monad (effective but makes the syntax much more convoluted) using runtime reflection (prevents ScalaJS from working correctly) using hetrogenous lists of typeclass instances (works well, but leads to a complex syntax) using macros together with tags to inhibit type erasure (the current approach) Monad Interpreters The quickest and easiest type of interpreter to create is one based off of monads. The interpreter will chain together the steps of the journey into instances of your given datatype and then use flatMap to bind them into each other. When taking this approach you only need to specify how to map interact, etc onto your chosen type. import ltbs.uniform._ import ltbs.uniform.validation.Rule import cats.{Id, Monoid, Monad} // we need to know how to tell and ask together // we don't care about tell, and our ask is a Monoid // so we just wrap the Monoid instance in a type // with two parameters case class Zero[T, A](monoid: Monoid[A]) { def value = monoid.empty } // wherever there is an implicit Monoid we want an // implicit Zero instance. implicit def zeroInstance[T,A: Monoid] = Zero[T,A](implicitly) object ZeroInterpreter extends MonadInterpreter[Id, Zero, Noop] { def monadInstance = implicitly[Monad[Id]] override def interactImpl[T, A]( key: String, tellValue: T, default: Option[A], validation: Rule[A], customContent: Map[String,(String, List[Any])], interaction: Zero[T,A] ): Id[A] = interaction.value override def askListImpl[A]( key: String, askJourney: (Option[Int], List[A]) =&gt; Id[A], default: Option[List[A]], validation: Rule[List[A]], customContent: Map[String,(String,List[Any])], asker: Noop[A] ): Id[List[A]] = Nil } Lets create a simple journey in order to test our interpreter - val journey = for { a &lt;- ask[String](\"a\") c &lt;- ask[Int](\"c\") } yield (a,c) We can now process the journey through the interpreter - // we want an implicit instance of Monoid for String and Int import cats.implicits._ // run the journey using the interpreter ZeroInterpreter.interpret(journey) // res0: (String, Int) = (\"\", 0)"
    }    
  ];

  idx = lunr(function () {
    this.ref("title");
    this.field("content");

    docs.forEach(function (doc) {
      this.add(doc);
    }, this);
  });

  docs.forEach(function (doc) {
    docMap.set(doc.title, doc.url);
  });
}

// The onkeypress handler for search functionality
function searchOnKeyDown(e) {
  const keyCode = e.keyCode;
  const parent = e.target.parentElement;
  const isSearchBar = e.target.id === "search-bar";
  const isSearchResult = parent ? parent.id.startsWith("result-") : false;
  const isSearchBarOrResult = isSearchBar || isSearchResult;

  if (keyCode === 40 && isSearchBarOrResult) {
    // On 'down', try to navigate down the search results
    e.preventDefault();
    e.stopPropagation();
    selectDown(e);
  } else if (keyCode === 38 && isSearchBarOrResult) {
    // On 'up', try to navigate up the search results
    e.preventDefault();
    e.stopPropagation();
    selectUp(e);
  } else if (keyCode === 27 && isSearchBarOrResult) {
    // On 'ESC', close the search dropdown
    e.preventDefault();
    e.stopPropagation();
    closeDropdownSearch(e);
  }
}

// Search is only done on key-up so that the search terms are properly propagated
function searchOnKeyUp(e) {
  // Filter out up, down, esc keys
  const keyCode = e.keyCode;
  const cannotBe = [40, 38, 27];
  const isSearchBar = e.target.id === "search-bar";
  const keyIsNotWrong = !cannotBe.includes(keyCode);
  if (isSearchBar && keyIsNotWrong) {
    // Try to run a search
    runSearch(e);
  }
}

// Move the cursor up the search list
function selectUp(e) {
  if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index) && (index > 0)) {
      const nextIndexStr = "result-" + (index - 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Move the cursor down the search list
function selectDown(e) {
  if (e.target.id === "search-bar") {
    const firstResult = document.querySelector("li[id$='result-0']");
    if (firstResult) {
      firstResult.firstChild.focus();
    }
  } else if (e.target.parentElement.id.startsWith("result-")) {
    const index = parseInt(e.target.parentElement.id.substring(7));
    if (!isNaN(index)) {
      const nextIndexStr = "result-" + (index + 1);
      const querySel = "li[id$='" + nextIndexStr + "'";
      const nextResult = document.querySelector(querySel);
      if (nextResult) {
        nextResult.firstChild.focus();
      }
    }
  }
}

// Search for whatever the user has typed so far
function runSearch(e) {
  if (e.target.value === "") {
    // On empty string, remove all search results
    // Otherwise this may show all results as everything is a "match"
    applySearchResults([]);
  } else {
    const tokens = e.target.value.split(" ");
    const moddedTokens = tokens.map(function (token) {
      // "*" + token + "*"
      return token;
    })
    const searchTerm = moddedTokens.join(" ");
    const searchResults = idx.search(searchTerm);
    const mapResults = searchResults.map(function (result) {
      const resultUrl = docMap.get(result.ref);
      return { name: result.ref, url: resultUrl };
    })

    applySearchResults(mapResults);
  }

}

// After a search, modify the search dropdown to contain the search results
function applySearchResults(results) {
  const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
  if (dropdown) {
    //Remove each child
    while (dropdown.firstChild) {
      dropdown.removeChild(dropdown.firstChild);
    }

    //Add each result as an element in the list
    results.forEach(function (result, i) {
      const elem = document.createElement("li");
      elem.setAttribute("class", "dropdown-item");
      elem.setAttribute("id", "result-" + i);

      const elemLink = document.createElement("a");
      elemLink.setAttribute("title", result.name);
      elemLink.setAttribute("href", result.url);
      elemLink.setAttribute("class", "dropdown-item-link");

      const elemLinkText = document.createElement("span");
      elemLinkText.setAttribute("class", "dropdown-item-link-text");
      elemLinkText.innerHTML = result.name;

      elemLink.appendChild(elemLinkText);
      elem.appendChild(elemLink);
      dropdown.appendChild(elem);
    });
  }
}

// Close the dropdown if the user clicks (only) outside of it
function closeDropdownSearch(e) {
  // Check if where we're clicking is the search dropdown
  if (e.target.id !== "search-bar") {
    const dropdown = document.querySelector("div[id$='search-dropdown'] > .dropdown-content.show");
    if (dropdown) {
      dropdown.classList.remove("show");
      document.documentElement.removeEventListener("click", closeDropdownSearch);
    }
  }
}
